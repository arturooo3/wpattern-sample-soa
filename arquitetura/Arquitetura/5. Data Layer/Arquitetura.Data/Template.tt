<# 
// ------------------------------------------------------------------------
// Copyright(c) 2009 Microsoft Corp.  All Rights Reserved.
//    
// To use this template:
//      1) Copy it into your solution and name it what you want your generated file named
//      2) Click on the EDMX file in Solution Explorer and set it's "Custom Tool" property
//         to empty in the property window. This causes Visual Studio to no longer generate 
//         the *.designer.cs file under the EDMX file
//      3) Update the SourceCsdlPath initialization below to the path to your .edmx file
//      4) When you make a change to the EDMX file in the designer, save it and click on
//         the "Transform All Templates" button in the Solution Explorer tool bar to cause
//         all .tt files in the project to generate their outputs
// ------------------------------------------------------------------------
#>
<#@ template language="C#" debug="false" hostspecific="true"#>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="System.Data" #>
<#@ assembly name="System.Data.Entity" #>
<#@ assembly name="System.Data.Entity.Design" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Data.Metadata.Edm" #>
<#@ import namespace="System.Data.Objects" #>
<#@ import namespace="System.Data.Objects.DataClasses" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Xml.Linq" #>
<#@ import namespace="System.Globalization" #>
<#@ import namespace="System.Reflection" #>
<# UserSettings userSettings = 
        new UserSettings
        {
            SourceCsdlPath = @"NorthwindModel.edmx",
            ReferenceCsdlPaths = new string [] {},
            FullyQualifySystemTypes = false,
            CreateContextAddToMethods = true
		};

ApplyUserSettings(userSettings);
Edm = new ItemCollectionWrapper(SourceCsdlPath, EdmToObjectNamespaceMap, ReferenceCsdlPaths, FullyQualifySystemTypes.Value, Errors, GetNamespaceSuggestion());
#>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated from a template and modified by Matthieu MEZIL.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Data.Objects;
using System.Data.Objects.DataClasses;
using System.Data.EntityClient;
using System.ComponentModel;
using System.Xml.Serialization;
using System.Runtime.Serialization;
using System.Collections.Generic;
<#
    
    if(!String.IsNullOrEmpty(Edm.ObjectNamespace))
    {
#>
namespace <#=Edm.ObjectNamespace#>
{
<#
        PushIndent(String.Empty.PadLeft(STANDARD_INDENT_LENGTH));
    }

    ////////
    //////// Write EntityContainer/ObjectContext classes
    ////////

    BeginRegion("Contexts");
    foreach(EntityContainerCodeWrapper container in Edm.SourceEntityContainers)
    {
		string interfaceName = "I" + container.ClassName;
#>
<#=container.TypeAccessibility#> interface <#=interfaceName#>
{
<#
		foreach(EntitySetObjectSetPropertyWrapper set in container.ObjectSetProperties)
        {
#>
	IObjectSet<<#=set.TypeName#>> <#=set.PropertyName#> { get; }
<#
	}
#>
}

<# 
	string comment = container.SummaryComment;
	if (container.SummaryComment != "No Metadata Documentation available.")
	{
#>
/// <summary>
/// <#=comment#>
/// </summary><#=container.GetLongDescriptionComment(_regionIndentLevel)#>
<#
	}
#>
<#=container.TypeAccessibility#> partial class <#=container.ClassName#> : ObjectContext, I<#=container.ClassName#>
{
    #region Constructors
    /// <summary>
    /// Initializes a new <#=container.ClassName#> object using the connection string found in the '<#=container.ModelName#>' section of the application configuration file.
    /// </summary>
    public <#=container.ClassName#>() : base("name=<#=container.ModelName#>", "<#=container.ModelName#>")
    {
        OnContextCreated();
    }

    /// <summary>
    /// Initialize a new <#=container.ClassName#> object.
    /// </summary>
    public <#=container.ClassName#>(string connectionString) : base(connectionString, "<#=container.ModelName#>")
    {
        OnContextCreated();
    }

    /// <summary>
    /// Initialize a new <#=container.ClassName#> object.
    /// </summary>
    public <#=container.ClassName#>(EntityConnection connection) : base(connection, "<#=container.ModelName#>")
    {
        OnContextCreated();
    }
    #endregion
    
    #region Partial Methods
    partial void OnContextCreated();
    #endregion
    
<#
        ////////
        //////// Write EntityContainer/ObjectContext ObjectSet properties
        ////////
        BeginRegion("ObjectSet Properties");
        foreach(EntitySetObjectSetPropertyWrapper set in container.ObjectSetProperties)
        {
#>
<# 
	comment = set.SummaryComment;
	if (comment != "No Metadata Documentation available.")
	{
#>
    /// <summary>
    /// <#=comment#>
    /// </summary><#=set.GetLongDescriptionComment(_regionIndentLevel)#>
<#
	}
#>
    <#=set.NewModifier#><#=set.GetterAccessibility#> ObjectSet<<#=set.TypeName#>> <#=set.PropertyName#>
    {
        get
        {
            if (<#=set.FieldName#> == null)
                <#=set.FieldName#> = CreateObjectSet<<#=set.TypeName#>>("<#=set.ModelName#>");
            return <#=set.FieldName#>;
        }
    }
    private ObjectSet<<#=set.TypeName#>> <#=set.FieldName#>;
	IObjectSet<<#=set.TypeName#>> <#= interfaceName #>.<#=set.PropertyName#> { get { return <#=set.PropertyName#>; } }

<#
        }
        EndRegion();
#>

<#
        ////////
        //////// Write EntityContainer/ObjectContext AddTo<EntitySet> methods
        ////////
        //////// AddTo methods are no longer necessary since the the EntitySet properties return ObjectSet<T> which has
        //////// an Add method on it already.
        //////// these are only generated for backwards compatibility
        //////// adjust the userSettings to turn them off.
        ////////
        BeginRegion("AddTo Methods");
        IEnumerable<EntitySetAddToMethodWrapper> addToMethods = CreateContextAddToMethods.Value ? container.AddToMethods : Enumerable.Empty<EntitySetAddToMethodWrapper>();
        foreach(EntitySetAddToMethodWrapper addTo in addToMethods)
        {
#>
        
<# 
	comment = addTo.SummaryComment;
	if (comment != "No Metadata Documentation available.")
	{
#>
    /// <summary>
    /// <#=comment#>
    /// </summary>
<#
	}
#>
    <#=addTo.EntityAccessibility#> void AddTo<#=addTo.ModelName#>(<#=addTo.TypeName#> <#=addTo.Parameter#>)
    {
        base.AddObject("<#=addTo.ModelName#>", <#=addTo.Parameter#>);
    }
<#
        }
        EndRegion();

        ////////
        //////// Write EntityContainer/ObjectContext Function Import methods
        ////////
        BeginRegion("Function Imports");
        foreach(FunctionImportMethodWrapper edmFunction in container.FunctionImports)
        {
#>

<# 
	comment = edmFunction.SummaryComment;
	if (comment != "No Metadata Documentation available.")
	{
#>
	/// <summary>
    /// <#=comment#>
    /// </summary><#=edmFunction.GetLongDescriptionComment(_regionIndentLevel)#><#=edmFunction.ParameterComments#>
<#
	}
#>
    <#=edmFunction.NewModifier#><#=edmFunction.MethodAccessibility#> ObjectResult<<#=edmFunction.ReturnElementTypeName#>> <#=edmFunction.FunctionName#>(<#=edmFunction.ParameterList#>)
    {
<#
            foreach(FunctionImportParameterWrapper parameter in edmFunction.Parameters)
            {
                if(!parameter.NeedsLocalVariable)
                    continue;
#>

        ObjectParameter <#=parameter.LocalVariableName#>;
        if (<#=parameter.IsNullableT ? parameter.FunctionParameterName + ".HasValue" : parameter.FunctionParameterName + " != null"#>)
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", <#=parameter.FunctionParameterName#>);
        }
        else
        {
            <#=parameter.LocalVariableName#> = new ObjectParameter("<#=parameter.EsqlParameterName#>", typeof(<#=parameter.RawClrTypeName#>));
        }
<#
            }
#>
        return base.ExecuteFunction<<#=edmFunction.ReturnElementTypeName#>>("<#=edmFunction.ModelName#>"<#=edmFunction.QueryExecuteParameterNameList#>);
    }
<#
        }
        EndRegion();
#>
    
<#
        ////////
        //////// Write EntityContainer/ObjectContext ObjectSet properties
        ////////
        BeginRegion("CreateObject methods with initializer");
        foreach(EntityTypeWrapper entity in Edm.SourceEntities.Where(etw => !etw.Source.Abstract))
        {
#>
    <#=entity.TypeAccessibility#> <#=entity.ClassName#> Create<#=entity.ClassName#>(<# 
		var properties = from property in ((IEnumerable<DataPropertyWrapper>)entity.PrimitiveTypeProperties).Union((IEnumerable<DataPropertyWrapper>)entity.ComplexTypeProperties)
						 where property.SetterAccessibility == "public" || property.PropertyAccessibility == "public"
						 select new {property.Name, property.PropertyType, Structure = ! (property is ComplexTypePropertyWrapper || property.PropertyType.Contains("<") || Type.GetType("System." + property.PropertyType).IsClass)};
		var enumerator = properties.GetEnumerator();
		bool next = enumerator.MoveNext();
		while (next)
		{
			var property = enumerator.Current;
			#><#=property.PropertyType#><# if (property.Structure) { #>?<# } #> <#=CamelCase(property.Name)#> = null<#
			next = enumerator.MoveNext(); 
			if (next) {#>, <#}}#>)
    {
		<#=entity.ClassName#> value = CreateObject<<#=entity.ClassName#>>();
<# foreach (var property in properties)
{
#>
		if (<#=CamelCase(property.Name)#> != null)
			value.<#=property.Name#> = <#=CamelCase(property.Name)#><#if(property.Structure){#>.Value<#}#>;
<#
}
#>
		return value;
	}

<#
        }
        EndRegion();
#>
}

<#
    }
    EndRegion();
#>

<#
    ////////
    //////// Write EntityType classes
    ////////
    BeginRegion("Entities");
    foreach(EntityTypeWrapper entity in Edm.SourceEntities.OrderBy(e => e.ModelName))
    {

#>
<# 
	string comment = entity.SummaryComment;
	if (comment != "No Metadata Documentation available.")
	{
#>
/// <summary>
/// <#=comment#>
/// </summary><#=entity.GetLongDescriptionComment(_regionIndentLevel)#>
<#
	}
#>
<#
        foreach(EntityTypeWrapper subType in Edm.GetAllDirectSubTypes(entity.Source))
        {
#>
[KnownTypeAttribute(typeof(<#=subType.TypeReferenceName#>))]
<#
        }
#>
<#=entity.TypeAccessibility#> <#=entity.AbstractOption#>partial class <#=entity.ClassName#> <#if(entity.BaseTypeName != "EntityObject"){#> : <#=entity.BaseTypeName#> <#}#>

{
<#
        WritePrimitiveTypeProperties(entity, typeof(EntityObject));
#>
<#
	if (entity.ComplexTypeProperties.Any())
	{
#>

<#
	}
#>
<#
        WriteComplexTypeProperties(entity, typeof(EntityObject));
        
        
#>

<#
        ////////
        //////// Write Navigation Properties
        ////////
        BeginRegion("Navigation Properties");
        foreach(NavigationPropertyWrapper navProperty in entity.NavigationProperties)
        {
            
#>
<#
            if(navProperty.ToMultiplicity == RelationshipMultiplicity.Many)
            {
				string navPropertyFieldName = "_" + CamelCase(navProperty.Name);
#>
	private ICollection<<#=navProperty.ElementType#>> <#=navPropertyFieldName#>;
<# 
	comment = navProperty.SummaryComment;
	if (comment != "No Metadata Documentation available.")
	{
#>
	/// <summary>
    /// <#=comment#>
    /// </summary><#=navProperty.GetLongDescriptionComment(_regionIndentLevel)#>
<#
	}
#>
    <#=navProperty.NewModifier#><#=navProperty.PropertyAccessibility#> virtual ICollection<<#=navProperty.ElementType#>> <#=navProperty.Name#> 
	{ 
		<#=navProperty.GetterAccessibility#>get
		{
			if (<#=navPropertyFieldName#> == null)
				<#=navPropertyFieldName#> = new List<<#=navProperty.ElementType#>>();
			return <#=navPropertyFieldName#>;
		}
		<#=navProperty.SetterAccessibility#>set { <#=navPropertyFieldName#> = value; }
	}
<#
           }
           else
           {
#>
<# 
	comment = navProperty.SummaryComment;
	if (comment != "No Metadata Documentation available.")
	{
#>
	/// <summary>
    /// <#=comment#>
    /// </summary><#=navProperty.GetLongDescriptionComment(_regionIndentLevel)#>
<#
	}
#>
    <#=navProperty.NewModifier#><#=navProperty.PropertyAccessibility#> virtual <#=navProperty.ElementType#> <#=navProperty.Name#> { <#=navProperty.GetterAccessibility#>get; <#=navProperty.SetterAccessibility#>set; }
<#
        	}
#>

<#
        }
        EndRegion();
#>
}

<#
    }
    EndRegion();
#>

<#
    ////////
    //////// Write ComplexType classes
    ////////
    BeginRegion("ComplexTypes");
    foreach(ComplexTypeWrapper complex in Edm.SourceComplexTypes.OrderBy(e => e.ModelName))
    {

#>
<# 
	string comment = complex.SummaryComment;
	if (comment != "No Metadata Documentation available.")
	{
#>
/// <summary>
/// <#=comment#>
/// </summary><#=complex.GetLongDescriptionComment(_regionIndentLevel)#>
<#
	}
#>
<#=complex.TypeAccessibility#> partial class <#=complex.ClassName#>
{
<#
        WritePrimitiveTypeProperties(complex, typeof(ComplexObject));
        WriteComplexTypeProperties(complex, typeof(ComplexObject));
#>
}

<#
    }
    EndRegion();
#>

<#
    if(!String.IsNullOrEmpty(Edm.ObjectNamespace))
    {
        PopIndent();
#>
}
<#
    }
    VerifyTypeUniqueness();
#>
<#+
    
    ////////
    //////// Reusable Template parts
    ////////

    ////////
    //////// Write Factory Method
    ////////
    private void WriteFactoryMethod(FactoryMethodWrapper factory)
    {
        if(factory.Parameters.Count == 0)
            return;

        if(factory.HasDeclaredMemberWithName(factory.MethodName))
        {
            // 6029 is the EntityClassGenerator error number for this conflict
            Errors.Add(new System.CodeDom.Compiler.CompilerError(SourceCsdlPath, -1, -1, "6029", 
                String.Format(CultureInfo.CurrentCulture, 
                        GetResourceString("Template_FactoryMethodNameConflict"), factory.MethodName, factory.ModelFullName)));
        }

        BeginRegion("Factory Method");
#>
    /// <summary>
    /// Create a new <#=factory.ClassName#> object.
    /// </summary><#=factory.ParameterComments#>
    public static <#=factory.ClassName#> <#=factory.MethodName#>(<#=factory.ParameterDeclarationList#>)
    {
        <#=factory.ClassName#> <#=factory.InstanceName#> = new <#=factory.ClassName#>();
<#+
        foreach(FactoryMethodParameterWrapper parameter in factory.Parameters)
        {
            if(parameter.IsComplexType)
            {
                // complex type initialization
#>
        <#=factory.InstanceName#>.<#=parameter.PropertyName#> = StructuralObject.VerifyComplexObjectIsNotNull(<#=parameter.Name#>, "<#=parameter.PropertyModelName#>");
<#+
            }
            else
            {
                // primitive type initialization
#>
        <#=factory.InstanceName#>.<#=parameter.PropertyName#> = <#=parameter.Name#>;
        
<#+
            }
        }
#>
        return <#=factory.InstanceName#>;
    }
<#+
        EndRegion();
        WriteLine("");
    }
    
    
    ////////
    //////// Write PrimitiveType Properties
    ////////
    private void WritePrimitiveTypeProperties(StructuralTypeWrapper typeWrapper, Type ultimateBaseType)
    {
        BeginRegion("Primitive Properties");
        foreach(PrimitiveTypePropertyWrapper property in typeWrapper.PrimitiveTypeProperties)
        {
			string comment = property.SummaryComment;
			if (comment != "No Metadata Documentation available.")
			{
#>
    /// <summary>
    /// <#=comment#>
    /// </summary><#=property.GetLongDescriptionComment(_regionIndentLevel)#>
<#+
			}
#>
    <#=property.NewModifier#><#=property.PropertyAccessibility#> virtual <#=property.PropertyType#> <#=property.Name#> { <#=property.GetterAccessibility#>get; <#=property.SetterAccessibility#>set; }
    
<#+
        }
        EndRegion();
    }

    ////////
    //////// Write ComplexType Properties
    ////////
    private void WriteComplexTypeProperties(StructuralTypeWrapper typeWrapper, Type ultimateBaseType)
    {
        BeginRegion("Complex Properties");
        foreach(ComplexTypePropertyWrapper property in typeWrapper.ComplexTypeProperties)
        {
#>

<#+ 
	string comment = property.SummaryComment;
	if (comment != "No Metadata Documentation available.")
	{
#>
    /// <summary>
    /// <#=comment#>
    /// </summary><#=property.GetLongDescriptionComment(_regionIndentLevel)#>
<#+
	}
#>
    <#=property.NewModifier#><#=property.PropertyAccessibility#> virtual <#=property.PropertyType#> <#=property.Name#> { <#=property.GetterAccessibility#>get; <#=property.SetterAccessibility#>set; }
<#+
        }
        EndRegion();
    }
#>
<#+

    ////////
    //////// Declare Template Public Properties
    ////////
    public string SourceCsdlPath{ get; set; }
    public IEnumerable<string> ReferenceCsdlPaths{ get; set; }
    public Nullable<bool> FullyQualifySystemTypes{ get; set; }
    public Nullable<bool> CreateContextAddToMethods{ get; set; }
    public Dictionary<string, string> EdmToObjectNamespaceMap
    { 
        get { return _edmToObjectNamespaceMap; } 
        set { _edmToObjectNamespaceMap = value; }
    }
    public Dictionary<string, string> _edmToObjectNamespaceMap = new Dictionary<string, string>();
    public Double SourceEdmVersion
    {
        get
        {
            if(Edm != null && Edm.Collection != null)
            {
                return Edm.Collection.EdmVersion;
            }
            
            return 0.0;
        }
    }
        
    ////////
    //////// Declare Template Private Properties
    ////////
    private ItemCollectionWrapper Edm { get; set; }
    private static System.Resources.ResourceManager ResourceManager
    {
        get
        {
            if(_resourceManager == null)
            {
                System.Resources.ResourceManager resourceManager = new System.Resources.ResourceManager("System.Data.Entity.Design", typeof(System.Data.Entity.Design.MetadataItemCollectionFactory).Assembly);
                System.Threading.Interlocked.CompareExchange(ref _resourceManager, resourceManager, null);
            }
            return _resourceManager;
        }
    }
    private static System.Resources.ResourceManager _resourceManager;
    
#>
<#+
    
    ////////
    //////// UTILITY METHODS
    ////////

    private static string PascalCase(string identifier)
    {
        if (string.IsNullOrEmpty(identifier))
            return identifier;

        if (identifier.Length == 1)
            return identifier[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant();

        return identifier[0].ToString(CultureInfo.InvariantCulture).ToUpperInvariant() + identifier.Substring(1);
    }
    
    private static string CamelCase(string identifier)
    {
        if (string.IsNullOrEmpty(identifier))
            return identifier;

        if (identifier.Length == 1)
            return identifier[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant();

        return identifier[0].ToString(CultureInfo.InvariantCulture).ToLowerInvariant() + identifier.Substring(1);
    }
    
    private static string GetEnumValueString(object enumValue)
    {
        Type type = enumValue.GetType();

        return type.FullName + "." + enumValue.ToString();
    }

    private static string GetResourceString(string resourceName)
    {
        return ResourceManager.GetString(resourceName,
             null); // take default culture
    }

    ////////
    //////// Code Generation Namespace Specific Utility Methods
    ////////
    
    private const string GETTER_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:GetterAccess";
    private const string SETTER_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:SetterAccess";
    private const string TYPE_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:TypeAccess";
    private const string METHOD_ACCESS = "http://schemas.microsoft.com/ado/2006/04/codegeneration:MethodAccess";
    private const string ACCESS_PROTECTED  = "Protected";
    private const string ACCESS_INTERNAL = "Internal";
    private const string ACCESS_PRIVATE = "Private";
    private static readonly Dictionary<string, int> AccessibilityRankIdLookup = new Dictionary<string, int> 
    { { "private",      1},
      { "internal",     2},
      { "protected",    3},
      { "public",       4}};

    
    private static void GetPropertyAccessibility(EdmMember property, 
        out string propertyAccessibility, 
        out string getterAccessibility,
        out string setterAccessibility)
    {
        getterAccessibility = GetAccessibility(property, GETTER_ACCESS);
        int getterRank = AccessibilityRankIdLookup[getterAccessibility];
        
        setterAccessibility = GetAccessibility(property, SETTER_ACCESS);
        int setterRank = AccessibilityRankIdLookup[setterAccessibility];
        
        int propertyRank = Math.Max(getterRank, setterRank);
        if(setterRank == propertyRank)
        {
            setterAccessibility = "";
        }
        
        if(getterRank == propertyRank)
        {
            getterAccessibility = "";
        }
        
        propertyAccessibility = AccessibilityRankIdLookup.Where(v => v.Value == propertyRank).Select(v => v.Key).Single();
    }

    // default to public, but try to get the user setting
    private static string GetAccessibility(MetadataItem item, string name)
    {
        string accessibility;
        if(TryGetStringMetadataPropertySetting(item, name, out accessibility))
        {
            return TranslateUserAccessibilityToCSharpAccessibility(accessibility);
        }
        
        return "public";
    }
    
    private static string TranslateUserAccessibilityToCSharpAccessibility(string userAccessibility)
    {
        if(userAccessibility == ACCESS_PROTECTED)
        {
            return "protected";
        }
        else if(userAccessibility == ACCESS_INTERNAL)
        {
            return "internal";
        }
        else if(userAccessibility == ACCESS_PRIVATE)
        {
            return "private";
        }
        else
        {
            // default to public
            return "public";
        }
    }
    
    private static bool TryGetStringMetadataPropertySetting(MetadataItem item, string propertyName, out string value)
    {
        MetadataProperty property = item.MetadataProperties.FirstOrDefault(p => p.Name == propertyName);
        if(property == null)
        {
            value = null;
            return false;
        }
        value = (string)property.Value;
        return value != null;
    }
    
    private void VerifyTypeUniqueness()
    {
        HashSet<string> hash = new HashSet<string>();
        IEnumerable<GlobalItem> allTypes = Edm.SourceTypes;
                        
        foreach(GlobalItem type in allTypes)
        {
            if(!hash.Add(GetGlobalItemName(type)))
            {
                // 6034 is the value used by System.Data.Entity.Design EntityClassGenerator
                Errors.Add(new System.CodeDom.Compiler.CompilerError(SourceCsdlPath, -1, -1, "6034", 
                 String.Format(CultureInfo.CurrentCulture, 
                    GetResourceString("Template_DuplicateTopLevelType"),
                 GetGlobalItemName(type))));
            }
        }
    }
    
    protected string GetGlobalItemName(GlobalItem item)
    {
        if (item is EdmType)
        {
            // Entity or Complex type
            return ((EdmType)item).Name;
        }
        else
        {
            // must be an EntityContainer
            return ((EntityContainer)item).Name;
        }
    }
        
    
    private const int STANDARD_INDENT_LENGTH = 4;
    private const string XMLCOMMENT_START = "///";
    private int _beforeRegionLength;
    private int _emptyRegionLength;
    private int _regionIndentLevel = -1;
    private void BeginRegion(string regionName)
    {
        _beforeRegionLength = GenerationEnvironment.Length;
        _regionIndentLevel++;
        Write(GetIndent(_regionIndentLevel));
        WriteLine("#region " + regionName);
        _emptyRegionLength = GenerationEnvironment.Length;
    }
    
    private void EndRegion()
    {
        int indentLevel = _regionIndentLevel;
        _regionIndentLevel--;
        if(_emptyRegionLength == GenerationEnvironment.Length)
            GenerationEnvironment.Length = _beforeRegionLength;
        else
        {
            Write(GetIndent(indentLevel));
            WriteLine("#endregion");
        }
    }
    
    private static string GetIndent(int indentLevel)
    {
        return String.Empty.PadLeft(indentLevel * STANDARD_INDENT_LENGTH);        
    }
    
    private string GetNamespaceSuggestion()
    {
#if !PREPROCESSED_TEMPLATE
        return this.Host.ResolveParameterValue("directiveId", "namespaceDirectiveProcessor", "namespaceHint");
#else
        return null;
#endif            
    }
    
    private void ApplyUserSettings(UserSettings userSettings)
    {
        // setup template user settings
        if(SourceCsdlPath == null)
        {
#if !PREPROCESSED_TEMPLATE
            SourceCsdlPath = Host.ResolvePath(userSettings.SourceCsdlPath);
#else
            SourceCsdlPath = userSettings.SourceCsdlPath;
#endif            
        }
        if(ReferenceCsdlPaths == null)
        {
            ReferenceCsdlPaths = userSettings.ReferenceCsdlPaths;
        }
            
        if(!FullyQualifySystemTypes.HasValue)
        {
            FullyQualifySystemTypes = userSettings.FullyQualifySystemTypes;
        }

        if(!CreateContextAddToMethods.HasValue)
        {
            CreateContextAddToMethods = userSettings.CreateContextAddToMethods;
        }
     }

    ////////
    //////// UniqueIdentifierService
    ////////
    private sealed class UniqueIdentifierService
    {
        private readonly HashSet<string> _knownIdentifiers;

        internal UniqueIdentifierService()
        {
            _knownIdentifiers = new HashSet<string>(StringComparer.Ordinal);
        }

        /// <summary>
        /// Given an identifier, makes it unique within the scope by adding
        /// a suffix (1, 2, 3, ...), and returns the adjusted identifier.
        /// </summary>
        internal string AdjustIdentifier(string identifier)
        {
            // find a unique name by adding suffix as necessary
            int numberOfConflicts = 0;
            string adjustedIdentifier = identifier;
            while (!_knownIdentifiers.Add(adjustedIdentifier))
            {
                ++numberOfConflicts;
                adjustedIdentifier = identifier + numberOfConflicts.ToString(CultureInfo.InvariantCulture);
            }

            return adjustedIdentifier;
        }
    }
    
    private class UserSettings
    {
        public string SourceCsdlPath{ get; set; }
        public string [] ReferenceCsdlPaths{ get; set; }
        public bool FullyQualifySystemTypes{ get; set; }
        public bool CreateContextAddToMethods{ get; set; }
    }
    
    
    ////////
    //////// Wrapper Classes
    ////////
    private class ItemCollectionWrapper : WrapperBase
    {
        private const string EDM_NAMESPACE_HOLDER = "";
        private readonly EdmItemCollection _collection;
        private readonly string _sourceSchemaPath;

        public ItemCollectionWrapper(string sourceSchemaPath, 
        Dictionary<string, string> edmToObjectNamespaceMap, 
        IEnumerable<String> referenceSchemaPaths, 
        bool fullyQualifySystemTypes,
        System.CodeDom.Compiler.CompilerErrorCollection errorCollection,
        string objectNamespaceOverride)
        :base(edmToObjectNamespaceMap, fullyQualifySystemTypes)
        {
            if(objectNamespaceOverride != null && !edmToObjectNamespaceMap.ContainsKey(EDM_NAMESPACE_HOLDER))
            {
                edmToObjectNamespaceMap.Add(EDM_NAMESPACE_HOLDER, objectNamespaceOverride);
            }
            
            _sourceSchemaPath = Path.GetFullPath(sourceSchemaPath);
            if(IsEdmxSource)
            {
                // we ignore referenceSchemaPaths when doing .edmx, it should be the full model
                _collection = GetEdmItemCollectionFromEdmxAndSetNamespaceName(_sourceSchemaPath, errorCollection);
            }
            else
            {
                _collection = CreateEdmItemCollection(new string [] {_sourceSchemaPath}.Union(referenceSchemaPaths), errorCollection);
            }
        }
        
        public bool IsEdmxSource{ get{ return Path.GetExtension(_sourceSchemaPath).ToLower() == ".edmx"; } }

        public EdmItemCollection Collection { get{ return _collection; }}

        public IEnumerable<EntityContainerCodeWrapper> SourceEntityContainers
        {
            get
            {
                return GetSourceSchemaTypes<EntityContainer>().Select(e => new EntityContainerCodeWrapper(e, this));
            }
        }

        public IEnumerable<EntityTypeWrapper> SourceEntities
        {
            get
            {
                return GetSourceSchemaTypes<EntityType>().Select(e => new EntityTypeWrapper(e, this));
            }
        }

        public IEnumerable<ComplexTypeWrapper> SourceComplexTypes
        {
            get
            {
                return GetSourceSchemaTypes<ComplexType>().Select(c => new ComplexTypeWrapper(c, this));
            }
        }

        public IEnumerable<AssociationCodeWrapper> SourceAssociations
        {
            get
            {
                return GetSourceSchemaTypes<AssociationType>().Select(a => new AssociationCodeWrapper(a, this));
            }
        }
        
        public IEnumerable<GlobalItem> SourceTypes
        {
            get
            {
                return GetSourceSchemaTypes<GlobalItem>().Where(i => i is StructuralType || i is EntityContainer);
            }
        }

        IEnumerable<T> GetSourceSchemaTypes<T>() where T : GlobalItem
        {
            if(!IsEdmxSource)
            {
                return _collection.GetItems<T>().Where(e => e.MetadataProperties.Any(mp => mp.Name == "SchemaSource" && (string)mp.Value == _sourceSchemaPath));
            }
            else
            {
                return _collection.GetItems<T>();
            }
        }
                
        public IEnumerable<EntityTypeWrapper>  GetAllDirectSubTypes(EntityType entity)
        {
            // don't limit to Soucre Types
            return _collection.GetItems<EntityType>().Where(b => b.BaseType == entity).Select(e => new EntityTypeWrapper(e, this));
        }

        public string ObjectNamespace
        {
            get
            {
                if(ModelNamespace == null)
                    return null;
                
                return GetObjectNamespace(ModelNamespace);
            }
        }
        
       
        private string _namespaceName = null;
        public override string ModelNamespace
        {
            get
            {
                if(_namespaceName == null)
                {
                    XmlDocument doc = new XmlDocument();
                    doc.Load(_sourceSchemaPath);
                    SetModelNamespace(doc.DocumentElement.GetAttribute("Namespace"));
                }
                return _namespaceName;
            }
        }
        private void SetModelNamespace(string modelNamespace)
        {
            _namespaceName = modelNamespace;
            if(!String.IsNullOrEmpty(_namespaceName) &&
               EdmToObjectNamespaceMap.ContainsKey(EDM_NAMESPACE_HOLDER) && 
               !EdmToObjectNamespaceMap.ContainsKey(_namespaceName))
            {
                string objectNamespace = EdmToObjectNamespaceMap[EDM_NAMESPACE_HOLDER];
                EdmToObjectNamespaceMap.Add(_namespaceName, objectNamespace);
                EdmToObjectNamespaceMap.Remove(EDM_NAMESPACE_HOLDER);
            }
        }        
        
        private const string EDMX_NAMESPACE_V1 = "http://schemas.microsoft.com/ado/2007/06/edmx";
        private const string EDMX_NAMESPACE_V2 = "http://schemas.microsoft.com/ado/2008/10/edmx";
        private const string CSDL_NAMESPACE_V1 = "http://schemas.microsoft.com/ado/2006/04/edm";
        private const string CSDL_NAMESPACE_V2 = "http://schemas.microsoft.com/ado/2008/09/edm";
        private EdmItemCollection GetEdmItemCollectionFromEdmxAndSetNamespaceName(string sourceSchemaPath,
                                            System.CodeDom.Compiler.CompilerErrorCollection errorCollection)
        {
            XElement element = XElement.Load(sourceSchemaPath, LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);

            XElement model = null;
            if(!TryGetModelNode(element, EDMX_NAMESPACE_V2, CSDL_NAMESPACE_V2, out model))
            {
                TryGetModelNode(element, EDMX_NAMESPACE_V1, CSDL_NAMESPACE_V1, out model);
            }
            
            if(model == null)
            {
                throw new InvalidOperationException("Unable to find the conceptual model node in the file " + sourceSchemaPath);
            }
            
            XmlReader xmlReader = null;
            try
            {
                // setup the namespace now
                SetModelNamespace(model.Attribute("Namespace").Value);
                xmlReader = XmlReader.Create(model.CreateReader(), new XmlReaderSettings());
                return CreateEdmItemCollection(new XmlReader[] { xmlReader }, errorCollection);
            }
            finally
            {
                if (xmlReader != null)
                    ((IDisposable)xmlReader).Dispose();
            }
        }
        
        private bool TryGetModelNode(XElement edmxDocument, string edmxNamespace, string edmNamespace, out XElement model)
        {
            XNamespace edmx = edmxNamespace;
            XNamespace edm = edmNamespace;
            model = null;
            
            XElement runtime = edmxDocument.Element(edmx + "Runtime");
            if(runtime == null)
                return false;
                
            XElement modelSection = runtime.Element(edmx + "ConceptualModels");
            if(modelSection == null)
                return false;
                
            model = modelSection.Element(edm + "Schema");
            return model != null;
        }
        
        private EdmItemCollection CreateEdmItemCollection(IEnumerable<string> schemas, 
                                            System.CodeDom.Compiler.CompilerErrorCollection errorCollection)
        {
            List<XmlReader> readers = new List<XmlReader>();
            try
            {
                foreach(string schema in schemas)
                {
                    readers.Add(XmlReader.Create(schema));
                }
                
                return CreateEdmItemCollection(readers, errorCollection);
                
            }
            finally
            {
                foreach(XmlReader reader in readers)
                {
                    if(reader != null)
                    {
                        reader.Close();
                    }
                }
            }
        }

        private EdmItemCollection CreateEdmItemCollection(IEnumerable<XmlReader> schemas,
                                            System.CodeDom.Compiler.CompilerErrorCollection errorCollection)
        {
            IList<EdmSchemaError> errors;
            EdmItemCollection collection = System.Data.Entity.Design.MetadataItemCollectionFactory.CreateEdmItemCollection(schemas, out errors);
            if(errors.Any(e => e.Severity == EdmSchemaErrorSeverity.Error))
            {
                foreach(EdmSchemaError error in errors)
                {
                    System.CodeDom.Compiler.CompilerError newError = new System.CodeDom.Compiler.CompilerError(error.SchemaLocation, error.Line, error.Column, error.ErrorCode.ToString(CultureInfo.InvariantCulture), error.Message);
                    newError.IsWarning = error.Severity == EdmSchemaErrorSeverity.Warning;
                    if(error.SchemaLocation == null)
                    {
                        newError.FileName = _sourceSchemaPath;
                    }
                    errorCollection.Add(newError);
                }
                // just return an empty one, the errors will let the user know about the problems
                return new EdmItemCollection();        
            }
            
            return collection;
        }
    }
    
    private abstract class WrapperBase
    {
        private readonly Microsoft.CSharp.CSharpCodeProvider _code;
        private readonly Dictionary<string, string> _edmToObjectNamespaceMap;
        private readonly string _modelNamespace;
        private readonly bool _fullyQualifySystemTypes;

        public WrapperBase(Dictionary<string, string> edmToObjectNamespaceMap, bool fullyQualifySystemTypes)
        {
            _code = new Microsoft.CSharp.CSharpCodeProvider();
            _edmToObjectNamespaceMap = edmToObjectNamespaceMap;
            _fullyQualifySystemTypes = fullyQualifySystemTypes;
        }
        
        public WrapperBase(WrapperBase wrapper)
        {
            // just grab references to the already created objects
            _code = wrapper._code;
            _modelNamespace = wrapper.ModelNamespace;
            _edmToObjectNamespaceMap = wrapper._edmToObjectNamespaceMap;
            _fullyQualifySystemTypes = wrapper._fullyQualifySystemTypes;
        }
        
        public virtual string SummaryComment{ get{ return GetMissingSummaryComment(); } }
        
        public virtual string GetMissingSummaryComment()
        {
            return GetResourceString("Template_CommentNoDocumentation");
        }
        
        public virtual string ModelNamespace { get{ return _modelNamespace; } }
        protected Dictionary<string, string> EdmToObjectNamespaceMap{ get { return _edmToObjectNamespaceMap; } }
        protected bool FullyQualifySystemTypes{ get{ return _fullyQualifySystemTypes; } }
        
        protected string GetObjectNamespace(string csdlNamespaceName)
        {
            string objectNamespace;
            if (_edmToObjectNamespaceMap.TryGetValue(csdlNamespaceName, out objectNamespace))
            {
                // this might be null
                return objectNamespace;
            }

            return csdlNamespaceName;
        }
        
        private static string CreateFullName(string namespaceName, string name)
        {
            if (string.IsNullOrEmpty(namespaceName))
            {
                return name;
            }

            return namespaceName + "." + name;
        }

        protected string GetFullyQualifiedStructuralTypeName(StructuralType structuralType)
        {
            return Escape(CreateFullName(GetObjectNamespace(structuralType.NamespaceName), structuralType.Name));
        }
        
        protected string Escape(string identifier)
        {
            return _code.CreateEscapedIdentifier(identifier);
        }
        
        public string CreatePrimitiveValue(object value)
        {
            System.CodeDom.CodePrimitiveExpression expression = new System.CodeDom.CodePrimitiveExpression(value);
            StringWriter writer = new StringWriter();
            _code.GenerateCodeFromExpression(expression, writer, new System.CodeDom.Compiler.CodeGeneratorOptions());
            return writer.ToString();
        }

        protected string GetStructuralTypeName(StructuralType structuralType)
        {
            if (structuralType.NamespaceName == ModelNamespace)
            {
                return Escape(structuralType.Name);        
            }
            else
            {
                return Escape(CreateFullName(GetObjectNamespace(structuralType.NamespaceName), structuralType.Name));
            }
        }
        
        protected string GetTypeName(TypeUsage typeUsage)
        {
            if(typeUsage.EdmType is ComplexType ||
               typeUsage.EdmType is EntityType)
            {
                return GetStructuralTypeName((StructuralType)typeUsage.EdmType);
            }
            else if (typeUsage.EdmType is PrimitiveType)
            {
                Type clrType;
                string typeName = GetPrimitiveTypeName(typeUsage, out clrType);
                if(clrType.IsValueType && IsNullable(typeUsage))
                {
                    return string.Format(CultureInfo.InvariantCulture, "Nullable<{0}>", typeName);
                }
                return typeName;
            }
            if(typeUsage.EdmType is CollectionType)
            {
                CollectionType collection = (CollectionType)typeUsage.EdmType;
                return GetTypeName(collection.TypeUsage);
            }
            
            return "UnknownType";
        }

        protected string GetPrimitiveTypeName(TypeUsage typeUsage)
        {
            Type clrType;
            return GetPrimitiveTypeName(typeUsage, out clrType);
        }

        protected string GetPrimitiveTypeName(TypeUsage typeUsage, out Type clrType)
        {
            clrType = GetPrimitiveTypeClrType(typeUsage);
            string typeName = clrType.Name;
            
            if(FullyQualifySystemTypes)
            {
                typeName = "global::" + clrType.FullName;
            }
            
            return typeName;
        }
        
        protected Type GetPrimitiveTypeClrType(TypeUsage typeUsage)
        {
            return ((PrimitiveType)typeUsage.EdmType).ClrEquivalentType;
        }

        protected static string Entityize(string text)
        {
            if (string.IsNullOrEmpty(text))
                return "";

            text = text.Replace("&","&amp;");
            text = text.Replace("<","&lt;").Replace(">","&gt;");
            return text.Replace("\'","&apos;").Replace("\"","&quot;");
        }

        protected static string FixParameterName(string name)
        {
            // FxCop consider 'iD' as violation, we will change any property that is 'id'(case insensitive) to 'ID'
            if (StringComparer.OrdinalIgnoreCase.Equals(name, "id"))
            {
                // it is an abreviation not an acronym so it should be all lower case
                return "id";
            }
            return CamelCase(name);
        }
        
        protected static TypeUsage GetElementType(TypeUsage typeUsage)
        {
            if(typeUsage == null)
                return null;
                
            if(typeUsage.EdmType is CollectionType)
            {
                return GetElementType(((CollectionType)typeUsage.EdmType).TypeUsage);
            }
            else
            {
                return typeUsage;
            }
        }

        protected static bool HasBaseMemberWithMatchingName(Type type, string memberName)
        {
            BindingFlags bindingFlags = BindingFlags.FlattenHierarchy | BindingFlags.NonPublic | BindingFlags.Public 
                        | BindingFlags.Instance | BindingFlags.Static;
            return type.GetMembers(bindingFlags).Where(m => IsVisibleMember(m)).Any(m => m.Name == memberName);
        }

        protected static bool IsVisibleMember(MemberInfo memberInfo)
        {
            if (memberInfo is EventInfo)
            {
                EventInfo ei = (EventInfo)memberInfo;
                MethodInfo add = ei.GetAddMethod();
                MethodInfo remove = ei.GetRemoveMethod();
                return IsVisibleMethod(add) || IsVisibleMethod(remove);
            }
            else if(memberInfo is FieldInfo)
            {
                FieldInfo fi = (FieldInfo)memberInfo;
                return !fi.IsPrivate && !fi.IsAssembly;
            }
            else if(memberInfo is MethodBase)
            {
                MethodBase mb = (MethodBase)memberInfo;
                if(mb.IsSpecialName)
                    return false;
                return IsVisibleMethod(mb);
            }
            else if(memberInfo is PropertyInfo)
            {
                PropertyInfo pi = (PropertyInfo)memberInfo;
                MethodInfo get = pi.GetGetMethod();
                MethodInfo set = pi.GetSetMethod();
                return IsVisibleMethod(get) || IsVisibleMethod(set);
            }
            
            return false;
        }
    
        protected static bool IsVisibleMethod(MethodBase methodBase)
        {
            if(methodBase == null)
                return false;
                
            return !methodBase.IsPrivate && !methodBase.IsAssembly;
        }
        
        private static bool IsNullable(TypeUsage typeUsage)
        {
            return (bool)typeUsage.Facets["Nullable"].Value;
        }
    }
    
    private class MetadataItemWrapper : WrapperBase
    {
        private readonly MetadataItem _item;
        public MetadataItemWrapper(MetadataItem item, WrapperBase wrapper)
        :base(wrapper)
        {
            _item = item;
        }
        
        protected MetadataItem Source { get{ return _item; } }
        public override string SummaryComment
        {
            get
            {
                if(Source.Documentation != null && Source.Documentation.Summary != null)
                {
                    return Entityize(Source.Documentation.Summary);
                }
                
                return GetMissingSummaryComment();
            }
        }
        
        public string GetLongDescriptionComment(int indentLevel)
        {
            if(Source.Documentation != null && !String.IsNullOrEmpty(Source.Documentation.LongDescription))
            {
                string comment = Environment.NewLine;
                string lineStart = GetIndent(indentLevel) + XMLCOMMENT_START + " ";
                comment += lineStart + "<LongDescription>" + Environment.NewLine;
                comment += lineStart + Entityize(Source.Documentation.LongDescription) + Environment.NewLine;
                comment += lineStart + "</LongDescription>";
                return comment;
            }
            return string.Empty;
        }
                
    }
    
    private class AssociationCodeWrapper : WrapperBase
    {
        private readonly AssociationType _associationType;
        public AssociationCodeWrapper(AssociationType associationType, WrapperBase wrapper)
        :base(wrapper)
        {
            _associationType = associationType;
        }
        
        public string ModelName{ get { return _associationType.Name; } }
        public string End0Name{ get{ return _associationType.AssociationEndMembers[0].Name; } }
        public string End0Multiplicity{ get { return GetEnumValueString(_associationType.AssociationEndMembers[0].RelationshipMultiplicity); } }
        public string End0TypeName{ get { return GetFullyQualifiedStructuralTypeName(_associationType.AssociationEndMembers[0].GetEntityType()); } }
        public string End1Name{ get { return _associationType.AssociationEndMembers[1].Name; } }
        public string End1Multiplicity{ get { return GetEnumValueString(_associationType.AssociationEndMembers[1].RelationshipMultiplicity); }  }
        public string End1TypeName{ get { return GetFullyQualifiedStructuralTypeName(_associationType.AssociationEndMembers[1].GetEntityType()); } }

    }
    
    private class EntityContainerCodeWrapper : MetadataItemWrapper
    {
        public EntityContainerCodeWrapper(EntityContainer entityContainer, WrapperBase wrapper)
        :base(entityContainer, wrapper)
        {
        }
        
        protected new EntityContainer Source { get{ return (EntityContainer)base.Source; } }
        public string ModelName{ get{ return Source.Name;} }
        public string ClassName{ get{ return Escape(Source.Name); } }
        public string TypeAccessibility{ get{ return GetAccessibility(Source, TYPE_ACCESS); } }
        public IEnumerable<EntitySet> EntitySets{ get{ return Source.BaseEntitySets.OfType<EntitySet>(); } }
        public IEnumerable<FunctionImportMethodWrapper> FunctionImports
        { 
            get
            { 
                return Source.FunctionImports.Where(f => f.ReturnParameter != null && GetElementType(f.ReturnParameter.TypeUsage) != null)
                                .Select(f => new FunctionImportMethodWrapper(f, this));
            }
        }
        public IEnumerable<EntitySetObjectSetPropertyWrapper> ObjectSetProperties{ get{ return EntitySets.Select(e => new EntitySetObjectSetPropertyWrapper(e, this)); } }
        public IEnumerable<EntitySetAddToMethodWrapper> AddToMethods{ get{ return EntitySets.Select(e => new EntitySetAddToMethodWrapper(e, this)); } }
    }
    
    private class EntitySetObjectSetPropertyWrapper : MetadataItemWrapper
    {
        public EntitySetObjectSetPropertyWrapper(EntitySet entitySet, WrapperBase wrapper)
        :base(entitySet, wrapper)
        {
        }
        
        protected new EntitySet Source { get{ return (EntitySet)base.Source; } }
        public string ModelName{ get { return Source.Name; } }
        public string PropertyName{ get { return Escape(Source.Name); } }
        public string FieldName{ get { return "_" + Source.Name; } }
        public string TypeName{ get { return GetStructuralTypeName(Source.ElementType); } }
        public string GetterAccessibility{ get { return GetAccessibility(Source, GETTER_ACCESS); } }
        public string NewModifier{ get { return HasBaseMemberWithMatchingName(typeof(ObjectContext), Source.Name) ? "new " : ""; } }
    }  

    private class EntitySetAddToMethodWrapper : WrapperBase
    {
        private readonly EntitySet _entitySet;
        public EntitySetAddToMethodWrapper(EntitySet entitySet, WrapperBase wrapper)
        :base(wrapper)
        {
            _entitySet = entitySet;
        }
        
            public string ModelName{ get { return _entitySet.Name; } }
            public string TypeName{ get { return GetStructuralTypeName(_entitySet.ElementType); } }
            public string EntityAccessibility{ get { return GetAccessibility(_entitySet.ElementType, TYPE_ACCESS); } }
            public string Parameter{ get { return Escape(FixParameterName(_entitySet.ElementType.Name)); } }
            public override string SummaryComment { get{ return String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_GenCommentAddToMethodCs"), ModelName); } }
    }

    private class FunctionImportMethodWrapper : MetadataItemWrapper
    {
        private readonly List<FunctionImportParameterWrapper> _parameters;
        public FunctionImportMethodWrapper(EdmFunction edmFunction, WrapperBase wrapper)
        :base(edmFunction, wrapper)
        {
            UniqueIdentifierService uniqueIdentifier = new UniqueIdentifierService();
            _parameters = Source.Parameters.Select(p => new FunctionImportParameterWrapper(p, this, uniqueIdentifier)).ToList();
            _parameters.ForEach(p => p.SetupLocalVariableName(uniqueIdentifier));
        }
        
        protected new EdmFunction Source { get{ return (EdmFunction)base.Source; } }
        public string ModelName{ get{ return Source.Name; } }
        public string FunctionName{ get{ return Escape(Source.Name); } }
        public string ReturnElementTypeName{ get{ return GetTypeName(GetElementType(Source.ReturnParameter.TypeUsage)); } }
        public string MethodAccessibility{ get{ return GetAccessibility(Source, METHOD_ACCESS); } }
        public string NewModifier{ get{ return HasBaseMemberWithMatchingName(typeof(ObjectContext), Source.Name) ? "new " : ""; } }
        public List<FunctionImportParameterWrapper> Parameters{ get{ return _parameters; } }
        public string ParameterList
        { 
            get
            { 
                return _parameters.Aggregate(string.Empty, (string accumulated, FunctionImportParameterWrapper input) =>
                    {
                        string prefix = ", ";
                        if (accumulated == string.Empty)
                        {
                            prefix = string.Empty;
                        }
                        return accumulated + prefix + input.TypeName + " " + input.FunctionParameterName;
                     });
             }
         }
        public string QueryExecuteParameterNameList{ get{ return _parameters.Select(p => p.NeedsLocalVariable ? p.LocalVariableName : p.FunctionParameterName).Aggregate(string.Empty, (string accumulated, string input) => {return accumulated + ", " + input;}); } }
        public string ParameterComments 
        { 
            get
            { 
                System.Text.StringBuilder builder = new System.Text.StringBuilder();
                foreach(FunctionImportParameterWrapper parameter in Parameters)
                {
                    builder.AppendLine();
                    builder.Append(GetIndent(1));
                    builder.Append(XMLCOMMENT_START);
                    builder.Append(String.Format(CultureInfo.InvariantCulture, " <param name=\"{0}\">{1}</param>", parameter.RawName, parameter.SummaryComment));
                }
                return builder.ToString(); 
            }
        }
    }
    
    private class FunctionImportParameterWrapper : MetadataItemWrapper
    {
        private readonly string _rawName;
        private string _localVariableName;
        public FunctionImportParameterWrapper(FunctionParameter parameter, WrapperBase wrapper, UniqueIdentifierService uniqueIdentifier)
        :base(parameter, wrapper)
        {
            _rawName = uniqueIdentifier.AdjustIdentifier(CamelCase(Source.Name));
            
        }
        
        protected new FunctionParameter Source { get{ return (FunctionParameter)base.Source; } }
        
        public string FunctionParameterName{ get{ return Escape(_rawName); } }
        public string RawName{ get{ return _rawName; } }
        public string TypeName{ get{ return Source.Mode == ParameterMode.In ? GetTypeName(Source.TypeUsage) : "ObjectParameter"; } }
        public string EsqlParameterName{ get{ return Source.Name; } }
        public string RawClrTypeName{ get{ return GetPrimitiveTypeName(Source.TypeUsage); } }
        public bool IsNullableT{ get{ return GetPrimitiveTypeClrType(Source.TypeUsage).IsValueType; } }
        public bool NeedsLocalVariable{ get{ return Source.Mode == ParameterMode.In; } }
        public string LocalVariableName{ get{ return _localVariableName; } }
        
        // we are doing this setup in a second pass so that the IL of the method matches
        // exactly to what EntityClassGenerator spits out for easy validation
        public void SetupLocalVariableName(UniqueIdentifierService uniqueIdentifier)
        {
            if(! NeedsLocalVariable)
                return;
            
            _localVariableName = uniqueIdentifier.AdjustIdentifier(CamelCase(Source.Name) + "Parameter");
        }
    }
    
    private class StructuralTypeWrapper : MetadataItemWrapper
    {
        public StructuralTypeWrapper(StructuralType type, WrapperBase wrapper)
        :base(type, wrapper)
        {
        }
        
        protected new  StructuralType Source{ get{ return (StructuralType)base.Source; } }
        public string ModelName{ get{ return Source.Name; } }
        public string ModelFullName{ get{ return Source.FullName; } }
        public string ClassName{ get{ return Escape(Source.Name); } }
        public string TypeAccessibility{ get{ return GetAccessibility(Source, TYPE_ACCESS); } }
        public FactoryMethodWrapper FactoryMethodWrapper{ get{ return new FactoryMethodWrapper(Source, this); } }
        public IEnumerable<PrimitiveTypePropertyWrapper> PrimitiveTypeProperties{ get{ return GetProperties().Where(p => p.DeclaringType == Source && p.TypeUsage.EdmType is PrimitiveType).Select(p => new PrimitiveTypePropertyWrapper(p, this)); } }
        public IEnumerable<ComplexTypePropertyWrapper> ComplexTypeProperties{ get{ return GetProperties().Where(p => p.DeclaringType == Source && p.TypeUsage.EdmType is ComplexType).Select(p => new ComplexTypePropertyWrapper(p, this)); } }

        private IEnumerable<EdmProperty> GetProperties()
        {
            if(Source.BuiltInTypeKind == BuiltInTypeKind.EntityType)
            {
                return ((EntityType)Source).Properties;
            }
            else
            {
                return ((ComplexType)Source).Properties;
            }
        }
        
        public bool HasDeclaredMemberWithName(string name)
        {
            return GetAllDeclaredMembers().Any(m => m.Name == name);  
        }
        
        private IEnumerable<EdmMember> GetAllDeclaredMembers()
        {
            if(Source is EntityType)
            {
                EntityType entity = (EntityType)Source;
                IEnumerable<EdmMember> declaredMembers = entity.Members.Where(m => m.DeclaringType == entity);
                IEnumerable<NavigationProperty> decalredNavigationProperties = entity.NavigationProperties.Where(n => n.DeclaringType == entity);
                
                return declaredMembers.Union(decalredNavigationProperties.Cast<EdmMember>());
            }
            
            return Source.Members.Where(m => m.DeclaringType == Source);
        }
    }
    
    private class EntityTypeWrapper : StructuralTypeWrapper 
    {
        public EntityTypeWrapper(EntityType entity, WrapperBase wrapper)
        :base(entity, wrapper)
        {
        }
        
        public new EntityType Source{ get{ return (EntityType)base.Source; } }

        public string AbstractOption{ get{ return Source.Abstract ? "abstract " : ""; } }
        public bool IsAbstract{ get{ return Source.Abstract; } }
        public string BaseTypeName{ get{ return Source.BaseType == null ? "EntityObject" : GetStructuralTypeName((StructuralType)Source.BaseType); } }
        public string TypeReferenceName{ get{ return GetStructuralTypeName(Source); } }
        
        public IEnumerable<NavigationPropertyWrapper> NavigationProperties{ get{ return Source.NavigationProperties.Where(n => n.DeclaringType == Source).Select(n => new NavigationPropertyWrapper(n, this)); } }
    }

    private class PropertyWrapper : MetadataItemWrapper
    {
        private readonly string _propertyAccessibility;
        private readonly string _setterAccessibility;
        private readonly string _getterAccessibility;

        public PropertyWrapper(EdmMember member, WrapperBase wrapper)
        :base(member, wrapper)
        {
            GetPropertyAccessibility(Source, out _propertyAccessibility, out _getterAccessibility, out _setterAccessibility);
        }

        protected new EdmMember Source{ get{ return (EdmMember)base.Source; } }
        public string PropertyAccessibility{ get{ return _propertyAccessibility; } }
        public string GetterAccessibility{ get{ return _getterAccessibility == string.Empty ? string.Empty : _getterAccessibility + " "; } }
        public string SetterAccessibility{ get{ return _setterAccessibility == string.Empty ? string.Empty : _setterAccessibility + " "; } }
        public string Name { get{ return Escape(Source.Name); } }
        public string ModelName { get{ return Source.Name; } }
        public string NewModifier { get{ return HasBaseMemberWithMatchingName(typeof(EntityObject), Source.Name) ? "new " : ""; } }
        
    }
    
    private class NavigationPropertyWrapper : PropertyWrapper
    {
        public NavigationPropertyWrapper(NavigationProperty edmProperty, WrapperBase wrapper)
        :base(edmProperty, wrapper)
        {
        }
    
        public new NavigationProperty Source{ get{ return (NavigationProperty)base.Source; } }
        public string ElementType { get{ return GetStructuralTypeName(Source.ToEndMember.GetEntityType()); } }
        public string RelationshipFullName { get{ return Source.RelationshipType.FullName; } }
        public string RelationshipNamespace { get{ return Source.RelationshipType.NamespaceName; } }
        public string RelationshipName { get{ return Source.RelationshipType.Name; } }
        
        public string RefPropertyName{ get{ return Source.Name + "Reference"; } }

        public string ToRoleName { get{ return Source.ToEndMember.Name; } }
        public RelationshipMultiplicity ToMultiplicity{ get { return Source.ToEndMember.RelationshipMultiplicity; } }
    }
    
    private class ComplexTypeWrapper : StructuralTypeWrapper
    {
        public ComplexTypeWrapper(ComplexType complex, WrapperBase wrapper)
        :base(complex, wrapper)
        {
        }
        
        public new ComplexType Source{ get{ return (ComplexType)base.Source; } }
        public string BaseTypeName{ get{ return Source.BaseType == null ? "ComplexObject" : GetStructuralTypeName((StructuralType)Source.BaseType); } }
    }

    private class FactoryMethodWrapper : StructuralTypeWrapper
    {
        private readonly string _instanceName;
        private readonly List<FactoryMethodParameterWrapper> _parameters;

        public FactoryMethodWrapper(StructuralType type, WrapperBase wrapper)
        :base(type, wrapper)
        {
            UniqueIdentifierService uniqueIdentifier = new UniqueIdentifierService();
            _instanceName = Escape(uniqueIdentifier.AdjustIdentifier((CamelCase(Source.Name))));
            IEnumerable<EdmProperty> properties = Source.Members.OfType<EdmProperty>().Where(p => IncludePropertyInFactoryMethod(p));
            _parameters = properties.Select(p => new FactoryMethodParameterWrapper(p, this, uniqueIdentifier)).ToList();
        }
        
        public string InstanceName{ get{ return _instanceName; } }
        public string MethodName{ get{ return "Create" + Source.Name; } }
        public List<FactoryMethodParameterWrapper> Parameters{ get{ return _parameters; } }
        public string ParameterDeclarationList
        { 
            get
            { 
                return _parameters.Aggregate(string.Empty, (string accumulated, FactoryMethodParameterWrapper input) =>
                    {
                        string prefix = ", ";
                        if (accumulated == string.Empty)
                        {
                            prefix = string.Empty;
                        }
                        return accumulated + prefix + input.TypeName + " " + input.Name;
                     });
             }
         }

        public string ParameterComments
        {
            get
            {
                System.Text.StringBuilder builder = new System.Text.StringBuilder();
                foreach(FactoryMethodParameterWrapper parameter in Parameters)
                {
                    builder.AppendLine();
                    builder.Append(GetIndent(1));
                    builder.Append(XMLCOMMENT_START);
                    builder.Append(String.Format(CultureInfo.InvariantCulture, " <param name=\"{0}\">", parameter.RawName));
                    builder.Append(String.Format(CultureInfo.CurrentCulture, GetResourceString("Template_CommentFactoryMethodParam"), parameter.PropertyModelName));
                    builder.Append("</param>");
                }
                return builder.ToString();
            }
        }        
            
        private bool IncludePropertyInFactoryMethod(EdmProperty edmProperty)
        {
            if (edmProperty.Nullable)
            {
                return false;
            }
            
            if (edmProperty.DefaultValue != null)
            {
                return false;
            }
            
            if(GetAccessibility(edmProperty, GETTER_ACCESS) != "public" &&
               GetAccessibility(edmProperty, SETTER_ACCESS) != "public")
            {
                // no public part to the property
                return false;
            }

            return true;
        }
    }
    
    private class FactoryMethodParameterWrapper : WrapperBase
    {
        private readonly EdmProperty _property;
        private readonly string _rawName;

        public FactoryMethodParameterWrapper(EdmProperty edmProperty, WrapperBase wrapper, UniqueIdentifierService uniqueIdentifier)
        :base(wrapper)
        {
            _property = edmProperty;
            _rawName = uniqueIdentifier.AdjustIdentifier(FixParameterName(_property.Name));
        }
    
        public string TypeName{ get{ return GetTypeName(_property.TypeUsage); } }
        public string Name{ get{ return Escape(_rawName); } }
        public string RawName{ get{ return _rawName; } }
        public string PropertyName{ get{ return Escape(_property.Name); } }
        public string PropertyModelName{ get{ return _property.Name; } }
        public bool IsComplexType{ get{ return _property.TypeUsage.EdmType is ComplexType; } }
    }
    
    
  
    private class DataPropertyWrapper : PropertyWrapper
    {
        public DataPropertyWrapper(EdmProperty edmProperty, WrapperBase wrapper)
        :base(edmProperty, wrapper)
        {
        }
        public new EdmProperty Source{ get{ return (EdmProperty)base.Source; } }
        public string PropertyType { get{ return GetTypeName(Source.TypeUsage); } }
        public string FieldName { get{ return "_" + Source.Name; } }
        public string ChangingMethodName { get{ return string.Format(CultureInfo.InvariantCulture, "On{0}Changing", Source.Name); } }
        public string ChangedMethodName { get{ return string.Format(CultureInfo.InvariantCulture, "On{0}Changed", Source.Name);  } }   
    }

    private class PrimitiveTypePropertyWrapper : DataPropertyWrapper
    {
        public PrimitiveTypePropertyWrapper(EdmProperty edmProperty, WrapperBase wrapper)
        :base(edmProperty, wrapper)
        {
        }
        public bool IsKeyProperty { get{ return Source.DeclaringType.BuiltInTypeKind != BuiltInTypeKind.EntityType ? false : ((EntityType)Source.DeclaringType).KeyMembers.Contains(Source); } }
        public bool IsByteArray{ get{ return GetPrimitiveTypeClrType(Source.TypeUsage) == typeof(byte[]); } }
        public bool IsNullable { get{ return Source.Nullable; } }
        public string FieldInit { get{ return GetFieldPropertyInitialization(Source); } }
        public string SetValidValueOptionalNullableParameter
        {
            get
            {
                string list = string.Empty;
                if (((PrimitiveType)Source.TypeUsage.EdmType).ClrEquivalentType.IsClass)
                {
                    list += ", " + CreatePrimitiveValue(IsNullable);
                }
                return list;
            }
        }

        private string GetFieldPropertyInitialization(EdmProperty property)
        {
            if(property.DefaultValue == null)
                return null;
            
            Type clrType = GetPrimitiveTypeClrType(property.TypeUsage);
            if(clrType == typeof(Guid))
            {
                return string.Format(CultureInfo.InvariantCulture, "new Guid(\"{0}\")", ((Guid)property.DefaultValue).ToString("D", CultureInfo.InvariantCulture));
            }
            else if(clrType == typeof(DateTime))
            {
                return string.Format(CultureInfo.InvariantCulture, "new DateTime({0}, DateTimeKind.Unspecified)", ((DateTime)property.DefaultValue).Ticks);
            }
            else if(clrType == typeof(byte[]))
            {
                string arrayInit = ((byte[])property.DefaultValue).Aggregate(string.Empty, (string accumulated, byte input) => {return accumulated == string.Empty ? input.ToString() : accumulated + ", " + input.ToString(CultureInfo.InvariantCulture);});
                return string.Format(CultureInfo.InvariantCulture, "new byte [] {{{0}}}", arrayInit);
            }
            else if(clrType == typeof(DateTimeOffset))
            {
                DateTimeOffset dto = (DateTimeOffset)property.DefaultValue;
                return string.Format(CultureInfo.InvariantCulture, "new DateTimeOffset({0}, new TimeSpan({1}))", dto.Ticks, dto.Offset.Ticks);
            }
            
            return CreatePrimitiveValue(property.DefaultValue);
        }

    }
    
    private class ComplexTypePropertyWrapper : DataPropertyWrapper
    {
        public ComplexTypePropertyWrapper(EdmProperty edmProperty, WrapperBase wrapper)
        :base(edmProperty, wrapper)
        {
        }

        public string InitializedTrackingField{ get{ return "_" + ModelName + "Initialized"; } }
    }
#>